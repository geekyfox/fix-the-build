## Chapter 5. The Ecclesiastes

The Book of Ecclesiastes is one of my favourite pieces in the Bible. It
teaches us that we're all going to die, and we will all be forgotten,
and everything we made will turn into dust, and nothing has any meaning
in the grand scheme of things, and that's exciting.

Wait, what?

Well, the "we're all going to die" part is not very exciting, but it's
also inevitable, and there's nothing we can do about it, so let's not
linger on it for too long. But "everything we made will turn into dust"
and "nothing has meaning in the grand scheme of things" are fantastic
things to realise, and let me explain why.

Imagine this wasn't true. Imagine that every minute decision you make
today had to withstand the scrutiny until the end of forever. Imagine
that every single thing you build had to be no less than the final
wisdom. Imagine that everything you do had to align with some Great
Meaning of the Universe. Imagine what a crushing burden of
responsibility that would be!

Thankfully, it's not the case. At the cosmic scale, nothing really
matters... And that's why we can just chill, have fun, and enjoy this
beautiful day for what it is.

Well... Except that some programmers willingly accept that burden.
That's why there's a lot of bad programming that stems from a question:
"assuming this piece of code will stick around for the rest of
eternity, how should I design it?"

Let's spend weeks and months debating the ideal design for this
internal utility, so it will be future-proof for generations of coders
to use it.

Let's apply these micro-optimisations. They'll pay off in the long run,
except that "long run" has to be decades to have any meaningful effect.

Let's design our architecture in such a way that we can seamlessly
inflate our coding force by a factor of ten, even though the customer
market that can justify such expansion clearly doesn't exist.

Let's abstract away the calendar, just in case our payroll software
will have to run on Mars and support 22 months per year.

So, here's one practical takeaway for you: accept the fact that your
solutions have a limited lifespan and design them around that
constraint. Don't build for Eternity. Pick a specific number N of
months, and build for that instead.

Naturally, if you're writing software for a space probe that will have
to run for decades without bugfix deploys, then your N will be in the
hundreds, it is what it is. In such projects, set up your entire
process around the expected longevity and be even more vigilant of the
spikes of "occasional perfectionism."

In a typical enterprise project, however, there's a good chance your
"eternal" code will live until the day you quit, and then your
colleagues will happily spend the next two weeks ripping it out, to the
relief of everyone involved.

If, however, this was the only thing to learn from this chapter, then
the Holy Inquisition will find me and burn me at the stake in the
middle of Rembrandtplein for the heresy of massively underselling the
Book of Ecclesiastes.

That's why I have another lesson. It's a tad touchy-feely, but also
much more important.

There is no capital-M Meaning of Life, and that's just the way it is.
And that's why you can make up your own meaning and run with it.

You like to build tools that make users' lives better? You like to
teach your colleagues? You like to solve puzzles? You like to design
systems that make sense? All of that matters, and nobody can take it
away from you. Eternity doesn't care, so do your best today.

Run with it.

In the next chapter, we will get practical. We will learn about
meditation techniques and why they are a crucial element of any
spiritual practice.

